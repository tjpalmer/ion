var gen_buf: char* = NULL;  // No auto init to NULL on globals?

// #define genf(...) buf_printf(gen_buf, __VA_ARGS__)
// #define genlnf(...) (genln(), genf(__VA_ARGS__))

var gen_indent: int;
var gen_pos: SrcPos;

var gen_headers_buf: char const**;

var gen_preamble_str: char const* = """
// Preamble
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#if _MSC_VER >= 1900 || __STDC_VERSION__ >= 201112L
// Visual Studio 2015 supports enough C99/C11 features for us.
#else
#error "C11 support required or Visual Studio 2015 or later"
#endif

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wvarargs"
#endif

#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>
#include <stdarg.h>
#include <assert.h>

typedef unsigned char uchar;
typedef signed char schar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;
typedef long long llong;
typedef unsigned long long ullong;

#ifdef _MSC_VER
#define alignof(x) __alignof(x)
#else
#define alignof(x) __alignof__(x)
#endif

#define va_start_ptr(args, arg) (va_start(*(args), *(arg)))
#define va_copy_ptr(dest, src) (va_copy(*(dest), *(src)))
#define va_end_ptr(args) (va_end(*(args)))

struct Any;
static void va_arg_ptr(va_list *args, struct Any any);
""";

var gen_postamble_str: char const* = """
static void va_arg_ptr(va_list *args, Any any) {
    switch (typeid_kind(any.type)) {
    case TYPE_BOOL:
        *(bool *)any.ptr = (bool)va_arg(*args, int);
        break;
    case TYPE_CHAR:
        *(char *)any.ptr = (char)va_arg(*args, int);
        break;
    case TYPE_UCHAR:
        *(uchar *)any.ptr = (uchar)va_arg(*args, int);
        break;
    case TYPE_SCHAR:
        *(schar *)any.ptr = (schar)va_arg(*args, int);
        break;
    case TYPE_SHORT:
        *(short *)any.ptr = (short)va_arg(*args, int);
        break;
    case TYPE_USHORT:
        *(ushort *)any.ptr = (ushort)va_arg(*args, int);
        break;
    case TYPE_INT:
        *(int *)any.ptr = va_arg(*args, int);
        break;
    case TYPE_UINT:
        *(uint *)any.ptr = va_arg(*args, uint);
        break;
    case TYPE_LONG:
        *(long *)any.ptr = va_arg(*args, long);
        break;
    case TYPE_ULONG:
        *(ulong *)any.ptr = va_arg(*args, ulong);
        break;
    case TYPE_LLONG:
        *(llong *)any.ptr = va_arg(*args, llong);
        break;
    case TYPE_ULLONG:
        *(ullong *)any.ptr = va_arg(*args, ullong);
        break;
    case TYPE_FLOAT:
        *(float *)any.ptr = (float)va_arg(*args, double);
        break;
    case TYPE_DOUBLE:
        *(double *)any.ptr = va_arg(*args, double);
        break;
    case TYPE_FUNC:
    case TYPE_PTR:
        *(void **)any.ptr = va_arg(*args, void *);
        break;
    default:
        assert(0 && "argument type not supported");
        break;
    }
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
""";

func genln() {
    buf_printf(&gen_buf, "\n%.*s", gen_indent * 4, "                                                                  ");
    gen_pos.line++;
}

func is_incomplete_array_typespec(typespec: Typespec*): bool {
    return typespec.kind == TYPESPEC_ARRAY && !typespec.detail.num_elems;
}

var char_to_escape: char[256] = {
    ['\0'] = '0',
    ['\n'] = 'n',
    ['\r'] = 'r',
    ['\t'] = 't',
    ['\v'] = 'v',
    ['\b'] = 'b',
    ['\a'] = 'a',
    ['\\'] = '\\',
    ['"'] = '"',
    ['\''] = '\'',
};

func gen_char(c: char) {
    if (char_to_escape[(:uchar)c]) {
        buf_printf(&gen_buf, "'\\%c'", char_to_escape[(:uchar)c]);
    } else if (isprint(c)) {
        buf_printf(&gen_buf, "'%c'", c);
    } else {
        buf_printf(&gen_buf, "'\\x%X'", (:uchar)c);
    }
}

func gen_str(str: char const*, multiline: bool) {
    if (multiline) {
        gen_indent++;
        genln();
    }
    buf_printf(&gen_buf, "\"");
    while (*str) {
        start: char const* = str;
        while (*str && isprint(*str) && !char_to_escape[(:uchar)*str]) {
            str++;
        }
        if (start != str) {
            buf_printf(&gen_buf, "%.*s", str - start, start);
        }
        if (*str) {
            if (char_to_escape[(:uchar)*str]) {
                buf_printf(&gen_buf, "\\%c", char_to_escape[(:uchar)*str]);
                if (str[0] == '\n' && str[1]) {
                    buf_printf(&gen_buf, "\"");
                    genln(); buf_printf(&gen_buf, "\"");
                }
            } else {
                #assert(!isprint(*str));
                buf_printf(&gen_buf, "\\x%X", (:uchar)*str);
            }
            str++;
        }
    }
    buf_printf(&gen_buf, "\"");
    if (multiline) {
        gen_indent--;
    }
}

func gen_sync_pos(pos: SrcPos) {
    if (gen_pos.line != pos.line || gen_pos.name != pos.name) {
        genln(); buf_printf(&gen_buf, "#line %d", pos.line);
        if (gen_pos.name != pos.name) {
            buf_printf(&gen_buf, " ");
            gen_str(pos.name, false);
        }
        gen_pos = pos;
    }
}

func cdecl_paren(str: char const*, c: char): char const* {
    return c && c != '[' ? (:char const*)strf("(%s)", str) : str;
}

func cdecl_name(type: Type*): char const* {
    type_name: char const* = type_names[type.kind];
    if (type_name) {
        return type_name;
    } else {
        #assert(type.sym);
        return get_gen_name(type.sym);
    }
}

// char *type_to_cdecl(type: Type*, str: char const*) {
//     switch (type.kind) {
//     case CMPL_TYPE_PTR:
//         return type_to_cdecl(type.base, cdecl_paren(strf("*%s", str), *str));
//     case CMPL_TYPE_CONST:
//         return type_to_cdecl(type.base, strf("const %s", cdecl_paren(str, *str)));
//     case CMPL_TYPE_ARRAY:
//         if (type.num_elems == 0) {
//             return type_to_cdecl(type.base, cdecl_paren(strf("%s[]", str), *str));
//         } else {
//             return type_to_cdecl(type.base, cdecl_paren(strf("%s[%zu]", str, type.num_elems), *str));
//         }
//     case CMPL_TYPE_FUNC: {
//         result: char* = NULL;
//         buf_printf(result, "(*%s)(", str);
//         if (type.func.num_params == 0) {
//             buf_printf(result, "void");
//         } else {
//             for (size_t i = 0; i < type.func.num_params; i++) {
//                 buf_printf(result, "%s%s", i == 0 ? "" : ", ", type_to_cdecl(type.func.params[i], ""));
//             }
//         }
//         if (type.func.has_varargs) {
//             buf_printf(result, ", ...");
//         }
//         buf_printf(result, ")");
//         return type_to_cdecl(type.func.ret, result);
//     }
//     default:
//         return strf("%s%s%s", cdecl_name(type), *str ? " " : "", str);
//     }
// }

// func gen_expr(expr: Expr*);

// func gen_expr_str(expr: Expr*): char const* {
//     temp: char* = gen_buf;
//     gen_buf = NULL;
//     gen_expr(expr);
//     result: char const* = gen_buf;
//     gen_buf = temp;
//     return result;
// }

var gen_name_map: Map;

func get_gen_name_or_default(ptr: void const*, default_name: char const*): char const* {
    name: char const* = map_get(&gen_name_map, ptr);
    if (!name) {
        sym: Sym* = get_resolved_sym(ptr);
        if (sym) {
            if (sym.external_name) {
                name = sym.external_name;
            } else if (sym.package.external_name) {
                external_name: char const* = sym.package.external_name;
                buf: char[256];
                if (sym.kind == SYM_CONST) {
                    ptr2: char* = buf;
                    for (str: char const* = external_name; *str && ptr2 < buf + sizeof(buf) - 1; str++) {
                        *ptr2 = toupper(*str);
                        ptr2++;
                    }
                    *ptr2 = 0;
                    if (ptr2 < buf + sizeof(buf)) {
                        external_name = buf;
                    }
                }
                name = strf("%s%s", external_name, sym.name);
            } else {
                name = sym.name;
            }
        } else {
            #assert(default_name);
            name = default_name;
        }
        map_put(&gen_name_map, ptr, (:void*)name);
    }
    return name;
}

func get_gen_name(ptr: void const*): char const* {
    return get_gen_name_or_default(ptr, "ERROR");
}

// char *typespec_to_cdecl(typespec: Typespec*, str: char const*) {
//     if (!typespec) {
//         return strf("void%s%s", *str ? " " : "", str);
//     }
//     switch (typespec.kind) {
//     case TYPESPEC_NAME:
//         return strf("%s%s%s", get_gen_name_or_default(typespec, typespec.name), *str ? " " : "", str);
//     case TYPESPEC_PTR:
//         return typespec_to_cdecl(typespec.base, cdecl_paren(strf("*%s", str), *str));
//     case TYPESPEC_CONST:
//         return typespec_to_cdecl(typespec.base, strf("const %s", cdecl_paren(str, *str)));
//     case TYPESPEC_ARRAY:
//         if (typespec.num_elems == 0) {
//             return typespec_to_cdecl(typespec.base, cdecl_paren(strf("%s[]", str), *str));
//         } else {
//             return typespec_to_cdecl(typespec.base, cdecl_paren(strf("%s[%s]", str, gen_expr_str(typespec.num_elems)), *str));
//         }
//     case TYPESPEC_FUNC: {
//         result: char* = NULL;
//         buf_printf(result, "(*%s)(", str);
//         if (typespec.func.num_args == 0) {
//             buf_printf(result, "void");
//         } else {
//             for (size_t i = 0; i < typespec.func.num_args; i++) {
//                 buf_printf(result, "%s%s", i == 0 ? "" : ", ", typespec_to_cdecl(typespec.func.args[i], ""));
//             }
//         }
//         if (typespec.func.has_varargs) {
//             buf_printf(result, ", ...");
//         }
//         buf_printf(result, ")");
//         return typespec_to_cdecl(typespec.func.ret, result);
//     }
//     default:
//         #assert(0);
//         return NULL;
//     }
// }

// func gen_func_decl(decl: Decl*) {
//     #assert(decl.kind == DECL_FUNC);
//     result: char* = NULL;
//     buf_printf(result, "%s(", get_gen_name(decl));
//     if (decl.func.num_params == 0) {
//         buf_printf(result, "void");
//     } else {
//         for (size_t i = 0; i < decl.func.num_params; i++) {
//             FuncParam param = decl.func.params[i];
//             if (i != 0) {
//                 buf_printf(result, ", ");
//             }
//             buf_printf(result, "%s", typespec_to_cdecl(param.type, param.name));
//         }
//     }
//     if (decl.func.has_varargs) {
//         buf_printf(result, ", ...");
//     }
//     buf_printf(result, ")");
//     gen_sync_pos(decl.pos);
//     if (decl.func.ret_type) {
//         genln(); buf_printf(&gen_buf, "%s", typespec_to_cdecl(decl.func.ret_type, result));
//     } else {
//         genln(); buf_printf(&gen_buf, "void %s", result);
//     }
// }

// func gen_reachable(sym: Sym*): bool {
//     return flag_fullgen || sym.reachable == REACHABLE_NATURAL;
// }

// func gen_forward_decls() {
//     for (it: Sym** = sorted_syms; it != buf_end(sorted_syms); it++) {
//         sym: Sym* = *it;
//         decl: Decl* = sym.decl;
//         if (!decl || !gen_reachable(sym)) {
//             continue;
//         }
//         if (is_decl_foreign(decl)) {
//             continue;
//         }
//         switch (decl.kind) {
//         case DECL_STRUCT:
//         case DECL_UNION: {
//             name: char const* = get_gen_name(sym);
//             genln(); buf_printf(&gen_buf, "typedef %s %s %s;", decl.kind == DECL_STRUCT ? "struct" : "union", name, name);
//             break;
//         }
//         default:
//             // Do nothing.
//             break;
//         }
//     }
// }

// func gen_aggregate(decl: Decl*) {
//     #assert(decl.kind == DECL_STRUCT || decl.kind == DECL_UNION);
//     if (decl.is_incomplete) {
//         return;
//     }
//     genln(); buf_printf(&gen_buf, "%s %s {", decl.kind == DECL_STRUCT ? "struct" : "union", get_gen_name(decl));
//     gen_indent++;
//     for (size_t i = 0; i < decl.aggregate.num_items; i++) {
//         AggregateItem item = decl.aggregate.items[i];
//         for (size_t j = 0; j < item.num_names; j++) {
//             gen_sync_pos(item.pos);
//             genln(); buf_printf(&gen_buf, "%s;", typespec_to_cdecl(item.type, item.names[j]));
//         }
//     }
//     gen_indent--;
//     genln(); buf_printf(&gen_buf, "};");
// }

// func gen_expr(expr: Expr*);

// func gen_paren_expr(expr: Expr*) {
//     buf_printf(&gen_buf, "(");
//     gen_expr(expr);
//     buf_printf(&gen_buf, ")");
// }

// func gen_expr_compound(expr: Expr*) {
//     expected_type: Type* = get_resolved_expected_type(expr);
//     if (expected_type && !is_ptr_type(expected_type)) {
//         buf_printf(&gen_buf, "{");
//     } else if (expr.compound.type) {
//         buf_printf(&gen_buf, "(%s){", typespec_to_cdecl(expr.compound.type, ""));
//     } else {
//         buf_printf(&gen_buf, "(%s){", type_to_cdecl(get_resolved_type(expr), ""));
//     }
//     for (size_t i = 0; i < expr.compound.num_fields; i++) {
//         if (i != 0) {
//             buf_printf(&gen_buf, ", ");
//         }
//         CompoundField field = expr.compound.fields[i];
//         if (field.kind == FIELD_NAME) {
//             buf_printf(&gen_buf, ".%s = ", field.name);
//         } else if (field.kind == FIELD_INDEX) {
//             buf_printf(&gen_buf, "[");
//             gen_expr(field.index);
//             buf_printf(&gen_buf, "] = ");
//         }
//         gen_expr(field.init);
//     }
//     if (expr.compound.num_fields == 0) {
//         buf_printf(&gen_buf, "0");
//     }
//     buf_printf(&gen_buf, "}");
// }

// typeid_kind_names: char const*[NUM_CMPL_TYPE_KINDS] = {
//     [CMPL_TYPE_NONE] = "CMPL_TYPE_NONE",
//     [CMPL_TYPE_VOID] = "CMPL_TYPE_VOID",
//     [CMPL_TYPE_BOOL] = "CMPL_TYPE_BOOL",
//     [CMPL_TYPE_CHAR] = "CMPL_TYPE_CHAR",
//     [CMPL_TYPE_UCHAR] = "CMPL_TYPE_UCHAR",
//     [CMPL_TYPE_SCHAR] = "CMPL_TYPE_SCHAR",
//     [CMPL_TYPE_SHORT] = "CMPL_TYPE_SHORT",
//     [CMPL_TYPE_USHORT] = "CMPL_TYPE_USHORT",
//     [CMPL_TYPE_INT] =  "CMPL_TYPE_INT",
//     [CMPL_TYPE_UINT] = "CMPL_TYPE_UINT",
//     [CMPL_TYPE_LONG] = "CMPL_TYPE_LONG",
//     [CMPL_TYPE_ULONG] = "CMPL_TYPE_ULONG",
//     [CMPL_TYPE_LLONG] = "CMPL_TYPE_LLONG",
//     [CMPL_TYPE_ULLONG] = "CMPL_TYPE_ULLONG",
//     [CMPL_TYPE_FLOAT] = "CMPL_TYPE_FLOAT",
//     [CMPL_TYPE_DOUBLE] = "CMPL_TYPE_DOUBLE",
//     [CMPL_TYPE_CONST] = "CMPL_TYPE_CONST",
//     [CMPL_TYPE_PTR] = "CMPL_TYPE_PTR",
//     [CMPL_TYPE_ARRAY] = "CMPL_TYPE_ARRAY",
//     [CMPL_TYPE_STRUCT] = "CMPL_TYPE_STRUCT",
//     [CMPL_TYPE_UNION] = "CMPL_TYPE_UNION",
//     [CMPL_TYPE_FUNC] = "CMPL_TYPE_FUNC",
// };

// func typeid_kind_name(type: Type*): char const* {
//     if (type.kind < NUM_CMPL_TYPE_KINDS) {
//         name: char const* = typeid_kind_names[type.kind];
//         if (name) {
//             return name;
//         }
//     }
//     return "CMPL_TYPE_NONE";
// }

// func is_excluded_typeinfo(type: Type*): bool {
//     while (type.kind == CMPL_TYPE_ARRAY || type.kind == CMPL_TYPE_CONST || type.kind == CMPL_TYPE_PTR) {
//         type = type.base;
//     }
//     return type.sym && !gen_reachable(type.sym);
// }

// func gen_typeid(type: Type*) {
//     if (type.size == 0 || is_excluded_typeinfo(type)) {
//         buf_printf(&gen_buf, "TYPEID0(%d, %s)", type.typeid, typeid_kind_name(type));
//     } else {
//         buf_printf(&gen_buf, "TYPEID(%d, %s, %s)", type.typeid, typeid_kind_name(type), type_to_cdecl(type, ""));
//     }
// }

// func gen_expr(expr: Expr*) {
//     switch (expr.kind) {
//     case EXPR_PAREN:
//         buf_printf(&gen_buf, "(");
//         gen_expr(expr.paren.expr);
//         buf_printf(&gen_buf, ")");
//         break;
//     case EXPR_INT: {
//         suffix_name: char const* = token_suffix_names[expr.int_lit.suffix];
//         switch (expr.int_lit.mod) {
//         case MOD_BIN:
//         case MOD_HEX:
//             buf_printf(&gen_buf, "0x%llx%s", expr.int_lit.val, suffix_name);
//             break;
//         case MOD_OCT:
//             buf_printf(&gen_buf, "0%llo%s", expr.int_lit.val, suffix_name);
//             break;
//         case MOD_CHAR:
//             gen_char((char)expr.int_lit.val);
//             break;
//         default:
//             buf_printf(&gen_buf, "%llu%s", expr.int_lit.val, suffix_name);
//             break;
//         }
//         break;
//     }
//     case EXPR_FLOAT:
//         buf_printf(&gen_buf, "%f%s", expr.float_lit.val, expr.float_lit.suffix == SUFFIX_D ? "" : "f");
//         break;
//     case EXPR_STR:
//         gen_str(expr.str_lit.val, expr.str_lit.mod == MOD_MULTILINE);
//         break;
//     case EXPR_NAME:
//         buf_printf(&gen_buf, "%s", get_gen_name_or_default(expr, expr.name));
//         break;
//     case EXPR_CAST:
//         buf_printf(&gen_buf, "(%s)(", typespec_to_cdecl(expr.cast.type, ""));
//         gen_expr(expr.cast.expr);
//         buf_printf(&gen_buf, ")");
//         break;
//     case EXPR_CALL: {
//         sym: Sym* = get_resolved_sym(expr.call.expr);
//         if (sym && sym.kind == SYM_TYPE) {
//             buf_printf(&gen_buf, "(%s)", get_gen_name(sym));
//         } else {
//             gen_expr(expr.call.expr);
//         }
//         buf_printf(&gen_buf, "(");
//         for (size_t i = 0; i < expr.call.num_args; i++) {
//             if (i != 0) {
//                 buf_printf(&gen_buf, ", ");
//             }
//             gen_expr(expr.call.args[i]);
//         }
//         buf_printf(&gen_buf, ")");
//         break;
//     }
//     case EXPR_INDEX:
//         gen_expr(expr.index.expr);
//         buf_printf(&gen_buf, "[");
//         gen_expr(expr.index.index);
//         buf_printf(&gen_buf, "]");
//         break;
//     case EXPR_FIELD:
//         gen_expr(expr.field.expr);
//         buf_printf(&gen_buf, "%s%s", get_resolved_type(expr.field.expr).kind == CMPL_TYPE_PTR ? "->" : ".", expr.field.name);
//         break;
//     case EXPR_COMPOUND:
//         gen_expr_compound(expr);
//         break;
//     case EXPR_UNARY:
//         buf_printf(&gen_buf, "%s(", token_kind_name(expr.unary.op));
//         gen_expr(expr.unary.expr);
//         buf_printf(&gen_buf, ")");
//         break;
//     case EXPR_BINARY:
//         buf_printf(&gen_buf, "(");
//         gen_expr(expr.binary.left);
//         buf_printf(&gen_buf, ") %s (", token_kind_name(expr.binary.op));
//         gen_expr(expr.binary.right);
//         buf_printf(&gen_buf, ")");
//         break;
//     case EXPR_TERNARY:
//         buf_printf(&gen_buf, "(");
//         gen_expr(expr.ternary.cond);
//         buf_printf(&gen_buf, " ? ");
//         gen_expr(expr.ternary.then_expr);
//         buf_printf(&gen_buf, " : ");
//         gen_expr(expr.ternary.else_expr);
//         buf_printf(&gen_buf, ")");
//         break;
//     case EXPR_SIZEOF_EXPR:
//         buf_printf(&gen_buf, "sizeof(");
//         gen_expr(expr.sizeof_expr);
//         buf_printf(&gen_buf, ")");
//         break;
//     case EXPR_SIZEOF_TYPE:
//         buf_printf(&gen_buf, "sizeof(%s)", typespec_to_cdecl(expr.sizeof_type, ""));
//         break;
//     case EXPR_ALIGNOF_EXPR:
//         buf_printf(&gen_buf, "alignof(%s)", type_to_cdecl(get_resolved_type(expr.alignof_expr), ""));
//         break;
//     case EXPR_ALIGNOF_TYPE:
//         buf_printf(&gen_buf, "alignof(%s)", typespec_to_cdecl(expr.alignof_type, ""));
//         break;
//     case EXPR_TYPEOF_EXPR: {
//         type: Type* = get_resolved_type(expr.typeof_expr);
//         #assert(type.typeid);
//         gen_typeid(type);
//         break;
//     }
//     case EXPR_TYPEOF_TYPE: {
//         type: Type* = get_resolved_type(expr.typeof_type);
//         #assert(type.typeid);
//         gen_typeid(type);
//         break;
//     }
//     case EXPR_OFFSETOF:
//         buf_printf(&gen_buf, "offsetof(%s, %s)", typespec_to_cdecl(expr.offsetof_field.type, ""), expr.offsetof_field.name);
//         break;
//     case EXPR_MODIFY:
//         if (!expr.modify.post) {
//             buf_printf(&gen_buf, "%s", token_kind_name(expr.modify.op));
//         }
//         gen_paren_expr(expr.modify.expr);
//         if (expr.modify.post) {
//             buf_printf(&gen_buf, "%s", token_kind_name(expr.modify.op));
//         }
//         break;
//     default:
//         #assert(0);
//     }
// }

// func gen_stmt(stmt: Stmt*);

// func gen_stmt_block(StmtList block) {
//     buf_printf(&gen_buf, "{");
//     gen_indent++;
//     for (size_t i = 0; i < block.num_stmts; i++) {
//         gen_stmt(block.stmts[i]);
//     }
//     gen_indent--;
//     genln(); buf_printf(&gen_buf, "}");
// }

// func gen_simple_stmt(stmt: Stmt*) {
//     switch (stmt.kind) {
//     case STMT_EXPR:
//         gen_expr(stmt.expr);
//         break;
//     case STMT_INIT:
//         if (stmt.init.type) {
//             init_typespec: Typespec* = stmt.init.type;
//             if (is_incomplete_array_typespec(stmt.init.type)) {
//                 size: Expr* = new_expr_int(init_typespec.pos, get_resolved_type(stmt.init.expr).num_elems, 0, 0);
//                 init_typespec = new_typespec_array(init_typespec.pos, init_typespec.base, size);
//             }
//             buf_printf(&gen_buf, "%s = ", typespec_to_cdecl(stmt.init.type, stmt.init.name));
//             if (stmt.init.expr) {
//                 gen_expr(stmt.init.expr);
//             } else {
//                 buf_printf(&gen_buf, "{0}");
//             }
//         } else {
//             buf_printf(&gen_buf, "%s = ", type_to_cdecl(unqualify_type(get_resolved_type(stmt.init.expr)), stmt.init.name));
//             gen_expr(stmt.init.expr);
//         }
//         break;
//     case STMT_ASSIGN:
//         gen_expr(stmt.assign.left);
//         buf_printf(&gen_buf, " %s ", token_kind_name(stmt.assign.op));
//         gen_expr(stmt.assign.right);
//         break;
//     default:
//         #assert(0);
//     }
// }

// static func is_char_lit(expr: Expr*): bool {
//     return expr.kind == EXPR_INT && expr.int_lit.mod == MOD_CHAR;
// }

// func gen_stmt(stmt: Stmt*) {
//     gen_sync_pos(stmt.pos);
//     switch (stmt.kind) {
//     case STMT_RETURN:
//         genln(); buf_printf(&gen_buf, "return");
//         if (stmt.expr) {
//             buf_printf(&gen_buf, " ");
//             gen_expr(stmt.expr);
//         }
//         buf_printf(&gen_buf, ";");
//         break;
//     case STMT_BREAK:
//         genln(); buf_printf(&gen_buf, "break;");
//         break;
//     case STMT_CONTINUE:
//         genln(); buf_printf(&gen_buf, "continue;");
//         break;
//     case STMT_BLOCK:
//         genln();
//         gen_stmt_block(stmt.block);
//         break;
//     case STMT_NOTE:
//         if (stmt.note.name == assert_name) {
//             genln(); buf_printf(&gen_buf, "assert(");
//             #assert(stmt.note.num_args == 1);
//             gen_expr(stmt.note.args[0].expr);
//             buf_printf(&gen_buf, ");");
//         }
//         break;
//     case STMT_IF:
//         if (stmt.if_stmt.init) {
//             genln(); buf_printf(&gen_buf, "{");
//             gen_indent++;
//             gen_stmt(stmt.if_stmt.init);
//         }
//         gen_sync_pos(stmt.pos);
//         genln(); buf_printf(&gen_buf, "if (");
//         if (stmt.if_stmt.cond) {
//             gen_expr(stmt.if_stmt.cond);
//         } else {
//             buf_printf(&gen_buf, "%s", stmt.if_stmt.init.init.name);
//         }
//         buf_printf(&gen_buf, ") ");
//         gen_stmt_block(stmt.if_stmt.then_block);
//         for (size_t i = 0; i < stmt.if_stmt.num_elseifs; i++) {
//             ElseIf elseif = stmt.if_stmt.elseifs[i];
//             buf_printf(&gen_buf, " else if (");
//             gen_expr(elseif.cond);
//             buf_printf(&gen_buf, ") ");
//             gen_stmt_block(elseif.block);
//         }
//         if (stmt.if_stmt.else_block.stmts) {
//             buf_printf(&gen_buf, " else ");
//             gen_stmt_block(stmt.if_stmt.else_block);
//         } else {
//             complete_note: Note* = get_stmt_note(stmt, complete_name);
//             if (complete_note) {
//                 buf_printf(&gen_buf, " else {");
//                 gen_indent++;
//                 gen_sync_pos(complete_note.pos);
//                 genln(); buf_printf(&gen_buf, "assert(\"@complete if/elseif chain failed to handle case\" && 0);");
//                 gen_indent--;
//                 genln(); buf_printf(&gen_buf, "}");
//             }
//         }
//         if (stmt.if_stmt.init) {
//             gen_indent--;
//             genln(); buf_printf(&gen_buf, "}");
//         }
//         break;
//     case STMT_WHILE:
//         genln(); buf_printf(&gen_buf, "while (");
//         gen_expr(stmt.while_stmt.cond);
//         buf_printf(&gen_buf, ") ");
//         gen_stmt_block(stmt.while_stmt.block);
//         break;
//     case STMT_DO_WHILE:
//         genln(); buf_printf(&gen_buf, "do ");
//         gen_stmt_block(stmt.while_stmt.block);
//         buf_printf(&gen_buf, " while (");
//         gen_expr(stmt.while_stmt.cond);
//         buf_printf(&gen_buf, ");");
//         break;
//     case STMT_FOR:
//         genln(); buf_printf(&gen_buf, "for (");
//         if (stmt.for_stmt.init) {
//             gen_simple_stmt(stmt.for_stmt.init);
//         }
//         buf_printf(&gen_buf, ";");
//         if (stmt.for_stmt.cond) {
//             buf_printf(&gen_buf, " ");
//             gen_expr(stmt.for_stmt.cond);
//         }
//         buf_printf(&gen_buf, ";");
//         if (stmt.for_stmt.next) {
//             buf_printf(&gen_buf, " ");
//             gen_simple_stmt(stmt.for_stmt.next);
//         }
//         buf_printf(&gen_buf, ") ");
//         gen_stmt_block(stmt.for_stmt.block);
//         break;
//     case STMT_SWITCH: {
//         genln(); buf_printf(&gen_buf, "switch (");
//         gen_expr(stmt.switch_stmt.expr);
//         buf_printf(&gen_buf, ") {");
//         bool has_default = false;
//         for (size_t i = 0; i < stmt.switch_stmt.num_cases; i++) {
//             SwitchCase switch_case = stmt.switch_stmt.cases[i];
//             for (size_t j = 0; j < switch_case.num_patterns; j++) {
//                 SwitchCasePattern pattern = switch_case.patterns[j];
//                 if (pattern.end) {
//                     Val start_val = get_resolved_val(pattern.start);
//                     Val end_val = get_resolved_val(pattern.end);
//                     if (is_char_lit(pattern.start) && is_char_lit(pattern.end)) {
//                         genln();
//                         for (int c = (int)start_val.ll; c <= (int)end_val.ll; c++) {
//                             buf_printf(&gen_buf, "case ");
//                             gen_char(c);
//                             buf_printf(&gen_buf, ": ");
//                         }
//                     } else {
//                         genln(); buf_printf(&gen_buf, "// ");
//                         gen_expr(pattern.start);
//                         buf_printf(&gen_buf, "...");
//                         gen_expr(pattern.end);
//                         genln();
//                         for (long long ll = start_val.ll; ll <= end_val.ll; ll++) {
//                             buf_printf(&gen_buf, "case %lld: ", ll);
//                         }
//                     }
//                 } else {
//                     genln(); buf_printf(&gen_buf, "case ");
//                     gen_expr(pattern.start);
//                     buf_printf(&gen_buf, ":");
//                 }
//             }
//             if (switch_case.is_default) {
//                 has_default = true;
//                 genln(); buf_printf(&gen_buf, "default:");
//             }
//             buf_printf(&gen_buf, " ");
//             buf_printf(&gen_buf, "{");
//             gen_indent++;
//             StmtList block = switch_case.block;
//             for (size_t j = 0; j < block.num_stmts; j++) {
//                 gen_stmt(block.stmts[j]);
//             }
//             genln(); buf_printf(&gen_buf, "break;");
//             gen_indent--;
//             genln(); buf_printf(&gen_buf, "}");
//         }
//         if (!has_default) {
//             note: Note* = get_stmt_note(stmt, complete_name);
//             if (note) {
//                 genln(); buf_printf(&gen_buf, "default:");
//                 gen_indent++;
//                 genln(); buf_printf(&gen_buf, "assert(\"@complete switch failed to handle case\" && 0);");
//                 genln(); buf_printf(&gen_buf, "break;");
//                 gen_indent--;
//             }
//         }
//         genln(); buf_printf(&gen_buf, "}");
//         break;
//     }
//     case STMT_LABEL:
//         genln(); buf_printf(&gen_buf, "%s: ;", stmt.label);
//         break;
//     case STMT_GOTO:
//         genln(); buf_printf(&gen_buf, "goto %s;", stmt.label);
//         break;
//     default:
//         genln();
//         gen_simple_stmt(stmt);
//         buf_printf(&gen_buf, ";");
//         break;
//     }
// }

// func gen_decl(sym: Sym*) {
//     decl: Decl* = sym.decl;
//     if (!decl || is_decl_foreign(decl)) {
//         return;
//     }
//     gen_sync_pos(decl.pos);
//     switch (decl.kind) {
//     case DECL_CONST:
//         genln(); buf_printf(&gen_buf, "#define %s (", get_gen_name(sym));
//         if (decl.const_decl.type) {
//             buf_printf(&gen_buf, "(%s)(", typespec_to_cdecl(decl.const_decl.type, ""));
//         }
//         gen_expr(decl.const_decl.expr);
//         if (decl.const_decl.type) {
//             buf_printf(&gen_buf, ")");
//         }
//         buf_printf(&gen_buf, ")");
//         break;
//     case DECL_VAR:
//         genln(); buf_printf(&gen_buf, "extern ");
//         if (decl.var.type && !is_incomplete_array_typespec(decl.var.type)) {
//             buf_printf(&gen_buf, "%s", typespec_to_cdecl(decl.var.type, get_gen_name(sym)));
//         } else {
//             buf_printf(&gen_buf, "%s", type_to_cdecl(sym.type, get_gen_name(sym)));
//         }
//         buf_printf(&gen_buf, ";");
//         break;
//     case DECL_FUNC:
//         gen_func_decl(decl);
//         buf_printf(&gen_buf, ";");
//         break;
//     case DECL_STRUCT:
//     case DECL_UNION:
//         gen_aggregate(decl);
//         break;
//     case DECL_TYPEDEF:
//         genln(); buf_printf(&gen_buf, "typedef %s;", typespec_to_cdecl(decl.typedef_decl.type, get_gen_name(sym)));
//         break;
//     case DECL_ENUM:
//         if (decl.enum_decl.type) {
//             genln(); buf_printf(&gen_buf, "typedef %s;", typespec_to_cdecl(decl.enum_decl.type, get_gen_name(decl)));
//         } else {
//             genln(); buf_printf(&gen_buf, "typedef int %s;", get_gen_name(decl));
//         }
//         break;
//     default:
//         #assert(0);
//         break;
//     }
//     genln();
// }

// func gen_sorted_decls() {
//     for (size_t i = 0; i < buf_len(sorted_syms); i++) {
//         if (sorted_syms[i].reachable == REACHABLE_NATURAL) {
//             gen_decl(sorted_syms[i]);
//         }
//     }
// }

// func gen_defs() {
//     for (it: Sym** = sorted_syms; it != buf_end(sorted_syms); it++) {
//         sym: Sym* = *it;
//         decl: Decl* = sym.decl;
//         if (sym.state != SYM_RESOLVED || !decl || is_decl_foreign(decl) || decl.is_incomplete || sym.reachable != REACHABLE_NATURAL) {
//             continue;
//         }
//         if (decl.kind == DECL_FUNC) {
//             gen_func_decl(decl);
//             buf_printf(&gen_buf, " ");
//             gen_stmt_block(decl.func.block);
//             genln();
//         } else if (decl.kind == DECL_VAR) {
//             if (decl.var.type && !is_incomplete_array_typespec(decl.var.type)) {
//                 genln(); buf_printf(&gen_buf, "%s", typespec_to_cdecl(decl.var.type, get_gen_name(sym)));
//             } else {
//                 genln(); buf_printf(&gen_buf, "%s", type_to_cdecl(sym.type, get_gen_name(sym)));
//             }
//             if (decl.var.expr) {
//                 buf_printf(&gen_buf, " = ");
//                 gen_expr(decl.var.expr);
//             }
//             buf_printf(&gen_buf, ";");
//         }
//     }
// }

// Map gen_foreign_headers_map;
// gen_foreign_headers_buf: char const**;

// static void add_foreign_header(name: char const*) {
//     name = str_intern(name);
//     if (!map_get(&gen_foreign_headers_map, name)) {
//         map_put(&gen_foreign_headers_map, name, (void *)1);
//         buf_push(gen_foreign_headers_buf, name);
//     }
// }

// gen_foreign_sources_buf: char const**;

// static void add_foreign_source(name: char const*) {
//     buf_push(gen_foreign_sources_buf, str_intern(name));
// }

// func gen_include(path: char const*) {
//     genln(); buf_printf(&gen_buf, "#include ");
//     if (*path == '<') {
//         buf_printf(&gen_buf, "%s", path);
//     } else {
//         gen_str(path, false);
//     }
// }

// func gen_foreign_headers() {
//     if (gen_foreign_headers_buf) {
//         genln(); buf_printf(&gen_buf, "// Foreign header files");
//         for (size_t i = 0; i < buf_len(gen_foreign_headers_buf); i++) {
//             gen_include(gen_foreign_headers_buf[i]);
//         }
//     }
// }

// func gen_foreign_sources() {
//     for (size_t i = 0; i < buf_len(gen_foreign_sources_buf); i++) {
//         gen_include(gen_foreign_sources_buf[i]);
//     }
// }

// gen_sources_buf: char const**;

// static void put_include_path(path: char[MAX_PATH], package: Package*, filename: char const*) {
//     if (*filename == '<') {
//         path_copy(path, filename);
//     } else {
//         path_copy(path, package.full_path);
//         path_join(path, filename);
//         path_absolute(path);
//     }
// }

// gen_preamble_buf: char*;
// gen_postamble_buf: char*;

// static void preprocess_package(package: Package*) {
//     if (!package.external_name) {
//         external_name: char* = NULL;
//         for (ptr: char const* = package.path; *ptr; ptr++) {
//             buf_printf(external_name, "%c", *ptr == '/' ? '_' : *ptr);
//         }
//         buf_printf(external_name, "_");
//         package.external_name = str_intern(external_name);
//     }
//     header_name: char const* = str_intern("header");
//     source_name: char const* = str_intern("source");
//     preamble_name: char const* = str_intern("preamble");
//     postamble_name: char const* = str_intern("postamble");
//     for (size_t i = 0; i < package.num_decls; i++) {
//         decl: Decl* = package.decls[i];
//         if (decl.kind != DECL_NOTE) {
//             continue;
//         }
//         Note note = decl.note;
//         if (note.name == foreign_name) {
//             for (size_t k = 0; k < note.num_args; k++) {
//                 NoteArg arg = note.args[k];
//                 expr: Expr* = note.args[k].expr;
//                 if (expr.kind != EXPR_STR) {
//                     fatal_error(decl.pos, "#foreign argument must be a string");
//                 }
//                 str: char const* = expr.str_lit.val;
//                 if (arg.name == header_name) {
//                     path: char[MAX_PATH];
//                     put_include_path(path, package, str);
//                     add_foreign_header(path);
//                 } else if (arg.name == source_name) {
//                     path: char[MAX_PATH];
//                     put_include_path(path, package, str);
//                     add_foreign_source(path);
//                 } else if (arg.name == preamble_name) {
//                     buf_printf(gen_preamble_buf, "%s\n", str);
//                 } else if (arg.name == postamble_name) {
//                     buf_printf(gen_postamble_buf, "%s\n", str);
//                 } else {
//                     fatal_error(decl.pos, "Unknown #foreign named argument '%s'", arg.name);
//                 }
//             }
//         }
//     }
// }

// func preprocess_packages() {
//     for (size_t i = 0; i < buf_len(package_list); i++) {
//         preprocess_package(package_list[i]);
//     }
// }

// func gen_typeinfo_header(kind: char const*, type: Type*) {
//     if (type_sizeof(type) == 0) {
//         buf_printf(&gen_buf, "&(TypeInfo){%s, .size = 0, .align = 0", kind);
//     } else {
//         ctype: char const* = type_to_cdecl(type, "");
//         buf_printf(&gen_buf, "&(TypeInfo){%s, .size = sizeof(%s), .align = alignof(%s)", kind, ctype, ctype);
//     }
// }

// func gen_typeinfo_fields(type: Type*) {
//     gen_indent++;
//     for (size_t i = 0; i < type.aggregate.num_fields; i++) {
//         TypeField field = type.aggregate.fields[i];
//         genln(); buf_printf(&gen_buf, "{");
//         gen_str(field.name, false);
//         buf_printf(&gen_buf, ", .type = ");
//         gen_typeid(field.type);
//         buf_printf(&gen_buf, ", .offset = offsetof(%s, %s)},", get_gen_name(type.sym), field.name);
//     }
//     gen_indent--;
// }

// #define CASE(kind, name) \
//     case kind: \
//         buf_printf(&gen_buf, "&(TypeInfo){" #kind ", .size = sizeof(" #name "), .align = sizeof(" #name "), .name = "); \
//         gen_str(#name, false); \
//         buf_printf(&gen_buf, "},"); \
//         break;

// func gen_typeinfo(type: Type*) {
//     switch (type.kind) {
//     CASE(CMPL_TYPE_BOOL, bool)
//     CASE(CMPL_TYPE_CHAR, char)
//     CASE(CMPL_TYPE_UCHAR, uchar)
//     CASE(CMPL_TYPE_SCHAR, schar)
//     CASE(CMPL_TYPE_SHORT, short)
//     CASE(CMPL_TYPE_USHORT, ushort)
//     CASE(CMPL_TYPE_INT, int)
//     CASE(CMPL_TYPE_UINT, uint)
//     CASE(CMPL_TYPE_LONG, long)
//     CASE(CMPL_TYPE_ULONG, ulong)
//     CASE(CMPL_TYPE_LLONG, llong)
//     CASE(CMPL_TYPE_ULLONG, ullong)
//     CASE(CMPL_TYPE_FLOAT, float)
//     CASE(CMPL_TYPE_DOUBLE, double)
//     case CMPL_TYPE_VOID:
//         buf_printf(&gen_buf, "&(TypeInfo){CMPL_TYPE_VOID, .name = \"void\", .size = 0, .align = 0},");
//         break;
//     case CMPL_TYPE_PTR:
//         buf_printf(&gen_buf, "&(TypeInfo){CMPL_TYPE_PTR, .size = sizeof(void *), .align = alignof(void *), .base = ");
//         gen_typeid(type.base);
//         buf_printf(&gen_buf, "},");
//         break;
//     case CMPL_TYPE_CONST:
//         gen_typeinfo_header("CMPL_TYPE_CONST", type);
//         buf_printf(&gen_buf, ", .base = ");
//         gen_typeid(type.base);
//         buf_printf(&gen_buf, "},");
//         break;
//     case CMPL_TYPE_ARRAY:
//         if (is_incomplete_array_type(type)) {
//             buf_printf(&gen_buf, "NULL, // Incomplete array type");
//         } else {
//             gen_typeinfo_header("CMPL_TYPE_ARRAY", type);
//             buf_printf(&gen_buf, ", .base = ");
//             gen_typeid(type.base);
//             buf_printf(&gen_buf, ", .count = %d},", type.num_elems);
//         }
//         break;
//     case CMPL_TYPE_STRUCT:
//     case CMPL_TYPE_UNION:
//         gen_typeinfo_header(type.kind == CMPL_TYPE_STRUCT ? "CMPL_TYPE_STRUCT" : "CMPL_TYPE_UNION", type);
//         buf_printf(&gen_buf, ", .name = ");
//         gen_str(get_gen_name(type.sym), false);
//         buf_printf(&gen_buf, ", .num_fields = %d, .fields = (TypeFieldInfo[]) {", type.aggregate.num_fields);
//         gen_typeinfo_fields(type);
//         genln(); buf_printf(&gen_buf, "}},");
//         break;
//     case CMPL_TYPE_FUNC:
//         buf_printf(&gen_buf, "NULL, // Func");
//         break;
//     case CMPL_TYPE_ENUM:
//         buf_printf(&gen_buf, "NULL, // Enum");
//         break;
//     case CMPL_TYPE_INCOMPLETE:
//         buf_printf(&gen_buf, "NULL, // Incomplete: %s", get_gen_name(type.sym));
//         break;
//     default:
//         buf_printf(&gen_buf, "NULL, // Unhandled");
//         break;
//     }
// }

// #undef CASE

// func gen_typeinfos() {
//     genln(); buf_printf(&gen_buf, "#define TYPEID0(index, kind) ((ullong)(index) | ((ullong)(kind) << 24))");
//     genln(); buf_printf(&gen_buf, "#define TYPEID(index, kind, ...) ((ullong)(index) | ((ullong)sizeof(__VA_ARGS__) << 32) | ((ullong)(kind) << 24))");
//     genln();
//     if (flag_notypeinfo) {
//         genln(); buf_printf(&gen_buf, "int num_typeinfos;");
//         genln(); buf_printf(&gen_buf, "const TypeInfo **typeinfos;");
//     } else {
//         int num_typeinfos = next_typeid;
//         genln(); buf_printf(&gen_buf, "const TypeInfo *typeinfo_table[%d] = {", num_typeinfos);
//         gen_indent++;
//         for (int typeid = 0; typeid < num_typeinfos; typeid++) {
//             genln(); buf_printf(&gen_buf, "[%d] = ", typeid);
//             type: Type* = get_type_from_typeid(typeid);
//             if (type && !is_excluded_typeinfo(type)) {
//                 gen_typeinfo(type);
//             } else {
//                 buf_printf(&gen_buf, "NULL, // No associated type");
//             }
//         }
//         gen_indent--;
//         genln(); buf_printf(&gen_buf, "};");
//         genln();
//         genln(); buf_printf(&gen_buf, "int num_typeinfos = %d;", num_typeinfos);
//         genln(); buf_printf(&gen_buf, "const TypeInfo **typeinfos = (const TypeInfo **)typeinfo_table;");
//     }
// }

// func gen_package_external_names() {
//     for (size_t i = 0; i < buf_len(package_list); i++) {
//     }
// }

// func gen_preamble() {
//     buf_printf(&gen_buf, "%s", gen_preamble_str);
//     if (gen_preamble_buf) {
//         genln();
//         genln(); buf_printf(&gen_buf, "// Foreign preamble");
//         genln(); buf_printf(&gen_buf, "%s", gen_preamble_buf);
//     }
// }

// func gen_postamble() {
//     buf_printf(&gen_buf, "%s", gen_postamble_str);
//     if (gen_postamble_buf) {
//         genln();
//         genln(); buf_printf(&gen_buf, "// Foreign postamble");
//         genln(); buf_printf(&gen_buf, "%s", gen_postamble_buf);
//     }
// }

func gen_all() {
    // preprocess_packages();
    // gen_buf = NULL;
    // gen_preamble();
    // gen_foreign_headers();
    // genln();
    // genln(); buf_printf(&gen_buf, "// Forward declarations");
    // gen_forward_decls();
    // genln();
    // genln(); buf_printf(&gen_buf, "// Sorted declarations");
    // gen_sorted_decls();
    // genln(); buf_printf(&gen_buf, "// Typeinfo");
    // gen_typeinfos();
    // genln();
    // genln(); buf_printf(&gen_buf, "// Definitions");
    // gen_defs();
    // genln(); buf_printf(&gen_buf, "// Foreign source files");
    // gen_foreign_sources();
    // genln();
    // gen_postamble();
}
